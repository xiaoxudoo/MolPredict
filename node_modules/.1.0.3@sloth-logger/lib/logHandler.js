'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var util = require('util');
var os = require('os');
var colors = require('colors');
var dateformat = require('dateformat');
var nodemailer = require('nodemailer');
var ansiUp = require('ansi_up');
var stripColorCodes = require('stripcolorcodes');

/**
 * Email log entries 
 * @param {Object} settings emailSettings value of Logger instance
 * @param {String} msg ansi text string of error message
 * @param {Function} cb Function to call once email is sent. Only called on error.
 */
var emailLog = function emailLog(settings, msg, cb) {
    var transporter = nodemailer.createTransport(settings.transportConfig);
    transporter.verify(function (err) {
        if (err) {
            return cb(err);
        }

        var data = {
            from: settings.from,
            to: settings.to,
            text: stripColorCodes(msg),
            html: ansiUp.ansi_to_html(msg.replace(new RegExp('\n', 'g'), '<br/>')),
            subject: settings.subject
        };

        transporter.sendMail(data, cb);
    });
};

/**
 * Creates a formatted line of ansi text based on level settings
 * @param {String} levelName Name of the log level
 * @param {Logger} logger Logger instance
 * @param {Array} args arguments sent to log 
 * @param {String} fullFilePath full path to file calling logger
 * @param {String} relativeFilePath path to file calling logger relative to process.cwd
 * @param {String} line Line number that logger is called from 
 * @returns {String} ansi string for log entry
 */
var formatLog = function formatLog(levelName, logger, args, fullFilePath, relativeFilePath, line) {
    var params = logger.levels[levelName];

    // Get date and time for log entry
    var logDate = dateformat(new Date(), params.dateFormat);

    // Get formatted log type flag
    var logLevelName = colors.blue('[') + colors[params.color].bold(levelName.toUpperCase()) + colors.blue(']');

    // Generate log message based on passed arguments
    var logMessage = '';
    if (params.inspect === true) {
        (function () {
            var msgParts = [];
            Object.keys(args).forEach(function (i) {
                msgParts.push(util.inspect(args[i], params.inspectOptions));
            });
            logMessage = msgParts.join(' ');
        })();
    } else {
        logMessage = util.format.apply(util, _toConsumableArray(args));
    }

    // Combine parts into log line based on provided format
    var log = eval('`' + params.format + '`');

    return log + '\n';
};

/**
 * Handles all calls to the loggers
 * @param {String} levelName Name of the log level
 * @param {Logger} logger Logger instance
 * @param {Array} args arguments sent to log 
 */
var processLog = function processLog(levelName, logger, args) {
    var params = logger.levels[levelName];

    // Only process log lines if threshold is less than or equal to current log level
    if (params.logLevelThreshold > logger.logLevel) {
        return;
    }

    // Get line and file for log entry
    var errStack = new Error().stack;
    var stacklist = errStack.split('\n')[3].split('at ')[1];
    var regEx = /\(([^)]+)\)/;
    var parsedStack = regEx.exec(stacklist) ? regEx.exec(stacklist)[1] : stacklist;
    var stackParts = parsedStack.split(':');
    var fullFilePath = stackParts[0];
    var relativeFilePath = fullFilePath.replace(process.cwd() + '/', '');
    var line = stackParts[1];

    if (Object.keys(logger.fileSpecificLogLevels).indexOf(fullFilePath) >= 0) {
        if (params.logLevelThreshold > logger.fileSpecificLogLevels[fullFilePath]) {
            return;
        }
    }

    var msg = formatLog(levelName, logger, args, fullFilePath, relativeFilePath, line);

    if (params.destination === process.stdout || params.destination === process.stderr) {
        params.destination.write(msg);
    } else {
        params.destination.write(stripColorCodes(msg));
    }

    if (logger.levels[levelName].aggregator !== null) {
        logger.levels[levelName].aggregator.addLog(msg);
    } else {
        if (params.sendEmail === true) {
            emailLog(logger.emailSettings, msg, function (err) {
                if (err) {
                    console.error('Error Sending Email: %s', err);
                }
            });
        }
    }
};

module.exports = { processLog: processLog, formatLog: formatLog, emailLog: emailLog };