'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logHandler = require('../logHandler.js');
var Aggregator = require('./Aggregator.js');
var _ = require('lodash');
var fs = require('fs');

var streamOpts = { flags: 'a', encoding: 'UTF-8' };
var defaultLevel = {
    'destination': process.stdout,
    'dateFormat': 'm/dd/yy h:MM:ss TT Z',
    'color': 'gray',
    'sendEmail': false,
    'inspect': false,
    'inspectOptions': {},
    'logLevelThreshold': 4,
    'format': '${logLevelName}[${logDate}][${relativeFilePath}:${line}] ${logMessage}',
    'aggregator': null
};

var Logger = function () {
    function Logger(opts) {
        var _this = this;

        _classCallCheck(this, Logger);

        opts = opts ? opts : {};

        // Currently set logLevel
        this.logLevel = opts && typeof opts.logLevel === 'number' ? opts.logLevel : 4;

        this.fileSpecificLogLevels = {};

        this.levels = {
            'error': _.merge({}, defaultLevel, { color: 'red', 'logLevelThreshold': 1 }),
            'warn': _.merge({}, defaultLevel, { color: 'magenta', 'logLevelThreshold': 2 }),
            'info': _.merge({}, defaultLevel, { color: 'cyan', 'logLevelThreshold': 3 }),
            'inspect': _.merge({}, defaultLevel, { color: 'white', inspect: true, inspectOptions: { showHidden: true, depth: 2, colors: true }, 'logLevelThreshold': 4 }),
            'debug': _.merge({}, defaultLevel, { color: 'yellow', 'logLevelThreshold': 4 })
        };

        // Add any log levels sent to constructor or update existing log levels
        if (opts.levels instanceof Object) {
            Object.keys(opts.levels).forEach(function (l) {
                if (_this.levels[l]) {
                    _this.levels[l] = _.merge(_this.levels[l], opts.levels[l]);
                } else {
                    _this.levels[l] = _.merge({}, defaultLevel, opts.levels[l]);
                }
            });
        }

        // set emailSetting if sent to constructor
        this.emailSettings = opts.emailSettings ? opts.emailSettings : null;

        // Generate functions with names of levels to handle logs
        Object.keys(this.levels).forEach(function (l) {
            if (typeof _this.levels[l].destination === 'string') {
                _this.levels[l].destination = new fs.createWriteStream(_this.levels[l].destination, streamOpts);
            }

            _this[l] = function () {
                logHandler.processLog(l, this, arguments);
            };
        });
    }

    _createClass(Logger, [{
        key: 'addCustomLogLevel',
        value: function addCustomLogLevel(obj) {
            var _this2 = this,
                _arguments = arguments;

            var l = obj.name;
            this.levels[obj.name] = defaultLevel;
            if (obj.filePath) {
                this.setLogFile(obj.name, obj.filePath);
            }
            this[l] = function () {
                return logHandler.processLog(l, _this2, _arguments);
            };
        }
    }, {
        key: 'setLevelProps',
        value: function setLevelProps(logLevel, props) {
            if (this.levels[logLevel.toLowerCase()]) {
                this.levels[logLevel.toLowerCase()] = _.merge({}, defaultLevel, this.levels[logLevel.toLowerCase()], props);
            } else {
                throw new TypeError(logLevel + ' does not exists as an available log level.');
            }
        }
    }, {
        key: 'sendEmail',
        value: function sendEmail(logLevel, _sendEmail) {
            if (this.levels[logLevel.toLowerCase()]) {
                this.levels[logLevel.toLowerCase()].sendEmail = _sendEmail;
            } else {
                throw new TypeError(logLevel + ' does not exists as an available log level.');
            }
        }
    }, {
        key: 'setLogLevelForThisFile',
        value: function setLogLevelForThisFile(level) {

            // Get file calling function
            var errStack = new Error().stack;
            var stacklist = errStack.split('\n')[2].split('at ')[1];
            var regEx = /\(([^)]+)\)/;
            var parsedStack = regEx.exec(stacklist) ? regEx.exec(stacklist)[1] : stacklist;
            var stackParts = parsedStack.split(':');
            var fullFilePath = stackParts[0];

            this.fileSpecificLogLevels[fullFilePath] = level;
        }
    }]);

    return Logger;
}();

module.exports = Logger;